<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Customise Insert/Edit Link Dialogue Box - Prickly Dev</title>
  <link rel="stylesheet" href="/gin-data/themes/gin-whitepaper/css/main.css">
</head>
<body>
<section class="section">
  <div class="container">
    <div class="heading">
      
    <h1 class="title">
      <a href="/customise-insert-edit-link-dialogue-box/">Customise Insert/Edit Link Dialogue Box</a>
    </h1>
    

    </div>
  </div>
</section>
<div class="container">
  <section id="primary-content" class="content">
    
    <article>
      <section class="content-body">
      &lt;p&gt;Recently, I had to create an easy way to select a custom post type (CPT) and insert it into a different CPT’s edit page. I’ve done this this type of thing before but, the last time I did, I took the approach of creating a replicable autocomplete field (allowing the user to add as many items as they want). Autocomplete made sense in this case because, overall, I think it made the post selection process faster. Implementation, however, was relatively slow. Why? Because I had to create:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;the autocomplete input field&lt;/li&gt;
&lt;li&gt;the logic that handled replication&lt;/li&gt;
&lt;li&gt;the logic that managed the autocomplete behaviour (yes, it was necessary)&lt;/li&gt;
&lt;li&gt;the input sanitisation logic&lt;/li&gt;
&lt;li&gt;the AJAX request&lt;/li&gt;
&lt;li&gt;a &lt;em&gt;wp&lt;em&gt;ajax&lt;/em&gt;&lt;/em&gt; function to handle the ajax request&lt;/li&gt;
&lt;li&gt;the code that would render the response&lt;/li&gt;
&lt;li&gt;the code that would parse the AJAX response, as well as update some page elements&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;None of these steps were particularly difficult, and I could quite easily replicate them, but the approach felt like overkill this time round. Users just needed to be able to select a single instance of &lt;em&gt;one&lt;/em&gt; CPT, very much like when adding a link to a post. This got me thinking and lead me to investigate using WordPress’s existing &lt;em&gt;Insert/Edit Link&lt;/em&gt; modal that’s available via the visual editor.&lt;/p&gt;
&lt;h3 id=&quot;a-little-less-work&quot;&gt;A little less work&lt;/h3&gt;
&lt;p&gt;Making the Insert/Edit Link modal window available outside of the visual editor was simple: hook into the &lt;code&gt;admin_enqueue_scripts&lt;/code&gt; and enqueue the &lt;code&gt;wp-link&lt;/code&gt; script for the required page:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function my_funky_func() {
    wp_enqueue_script(&amp;#39;wp-link&amp;#39;);
}
add_action(&amp;#39;admin_enqueue_scripts&amp;#39;, &amp;#39;my_funky_func&amp;#39;);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In the JS for the edit page, &lt;code&gt;wpLink.open()&lt;/code&gt; must triggered by a click event and handled:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    $(&amp;#39;body&amp;#39;).on(&amp;#39;click&amp;#39;, &amp;#39;#my-modal-trigger&amp;#39;, function(e) {

        // This can be any value. Its sole purpose is to let us know if the modal that&amp;#39;s open
        // is the default or a custom one.
        window.mySpecialModalVariable = e.target.dataset.target;

        // This must have a value because the link dialogue expects it to 
        // (a wp_editor instance, actually, but that part doesn&amp;#39;t matter here...as long as it has a value).
        wpActiveEditor = true;

        // Open the link popup.
        wpLink.open();

        // So no other action is triggered.
        return false;
    });
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The submission and cancellation of the Insert/Edit Link dialogue box also needs to be handled. So off we go…&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    function closeMyModal() {

        // Again, an editor instance is expected, as upon closing .focus() is called on
        // wpLink.textarea, so we need to provide a jQuery object to .focus() on.
        wpLink.textarea = $(&amp;#39;body&amp;#39;);
        wpLink.close();

        window.mySpecialModalVariable = false;
        e.preventDefault ? e.preventDefault() : e.returnValue = false;
        e.stopPropagation();
    };

    // When the dialogue box&amp;#39;s submit button is clicked...
    $(&amp;#39;body&amp;#39;).on(&amp;#39;click&amp;#39;, &amp;#39;#wp-link-submit&amp;#39;, function(e) {

        var selectedItem = wpLink.getAttrs();

        if (!selectedItem.href) {
            closeMyModal();
        }

        // Do something with the selectedItem, then close the dialogue box.

       closeMyModal();
    });

    // When the user clicks the cancel button, close button, or overlay...
    $(&amp;#39;body&amp;#39;).on(&amp;#39;click&amp;#39;, &amp;#39;#wp-link-cancel, #wp-link-close, #wp-link-backdrop&amp;#39;, function(e) {

        // Do whatever&amp;#39;s necessary, then...

        closeMyModal();
    });
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;good-but-not-good-enough-&quot;&gt;Good, but not good enough…&lt;/h3&gt;
&lt;p&gt;The above works. Great. The problem with it is that it allows you to select &lt;em&gt;any&lt;/em&gt; post type. You might want this. I didn’t. So I needed to modify the AJAX call and/or the query that returns the results.&lt;/p&gt;
&lt;p&gt;It turns out that it’s relatively simple (but not totally obvious how) to manipulate the Insert/Edit modal’s content: &lt;em&gt;intercept the AJAX request&lt;/em&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$(document).ready(function() {

    $.ajaxSetup({
        beforeSend: function(jqXHR, data) {

            // I don&amp;#39;t want to do anything if there&amp;#39;s no data to send.
            if (!data.data) return true;

            // I only want to modify the request if it&amp;#39;s for my custom modal. 
            if (!window.mySpecialModalVariable) return true;

            // Made it. Now, I need to know where the AJAX is going.
            // Break down the query params into key/value pairs and find out.
            $.each(data.data.split(&amp;#39;&amp;amp;&amp;#39;), function(i, kv) {
                var kv = kv.split(&amp;#39;=&amp;#39;);
                if (kv[0] == &amp;#39;action&amp;#39; &amp;amp;&amp;amp; kv[1] == &amp;#39;wp-link-ajax&amp;#39;) {
                    data.data += &amp;#39;&amp;amp;my-special-param=1&amp;#39;;
                }
            });

            return true;
        }
    });
});
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Looking good so far. You may have noticed the &lt;code&gt;window.mySpecialModalVariable&lt;/code&gt; in the code above. This exists for the purpose of letting us know if the AJAX request is coming from a custom modal or the default one. It’s given a value when the custom modal is opened, and it’s set to false when the dialogue box is closed via a call to &lt;code&gt;closeMyModal()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Having this variable isn’t imperative, but if you (might ever) have a visual editor on the same page in which this code will run, you’d find that &lt;em&gt;all&lt;/em&gt; AJAX requests to &lt;code&gt;wp-link-ajax&lt;/code&gt; would be modified, and the selection of posts in regular Insert/Edit Link modals would be limited to the same ones in your custom modal.&lt;/p&gt;
&lt;h3 id=&quot;and-finally-&quot;&gt;And finally…&lt;/h3&gt;
&lt;p&gt;All that remains is to filter &lt;code&gt;wp_link_query_args&lt;/code&gt; and check for &lt;code&gt;my-special-param&lt;/code&gt;‘s presence.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function awesome_wp_link_filter($args) {
    global $post;

    if (array_key_exists(&amp;#39;my-special-param&amp;#39;, $_POST)) {
        $args[&amp;#39;post_type&amp;#39;] = array(&amp;#39;my-special-post-type&amp;#39;);
    }

    return $args;
}

add_filter(&amp;#39;wp_link_query_args&amp;#39;, &amp;#39;awesome_wp_link_filter&amp;#39;, 99);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And that’s it. When the custom modal is launched, it will only display a list of &lt;code&gt;my-special-post-type&lt;/code&gt;s. It might not seem like a big deal, but when you’ve got 100,000+ rows in &lt;code&gt;wp_posts&lt;/code&gt;, 20+ different post types, and there are only 50 posts of the CPT you’re after, it’s nice to be able to select from a subset rather than the whole set.&lt;/p&gt;

      </section>
    </article>

  </section>
</div>

  
</body>
</html>
