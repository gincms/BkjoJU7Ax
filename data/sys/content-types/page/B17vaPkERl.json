{
  "title": "Customise Insert/Edit Link Dialogue Box",
  "subtitle": "",
  "slug": "customise-insert-edit-link-dialogue-box",
  "section": "",
  "url": "/customise-insert-edit-link-dialogue-box/",
  "body": "\nRecently, I had to create an easy way to select a custom post type (CPT) and insert it into a different CPT’s edit page. I’ve done this this type of thing before but, the last time I did, I took the approach of creating a replicable autocomplete field (allowing the user to add as many items as they want). Autocomplete made sense in this case because, overall, I think it made the post selection process faster. Implementation, however, was relatively slow. Why? Because I had to create:\n\n- the autocomplete input field\n- the logic that handled replication\n- the logic that managed the autocomplete behaviour (yes, it was necessary)\n- the input sanitisation logic\n- the AJAX request\n- a *wp_ajax_* function to handle the ajax request\n- the code that would render the response\n- the code that would parse the AJAX response, as well as update some page elements\n\nNone of these steps were particularly difficult, and I could quite easily replicate them, but the approach felt like overkill this time round. Users just needed to be able to select a single instance of *one* CPT, very much like when adding a link to a post. This got me thinking and lead me to investigate using WordPress’s existing *Insert/Edit Link* modal that’s available via the visual editor.\n\n### A little less work\n\nMaking the Insert/Edit Link modal window available outside of the visual editor was simple: hook into the `admin_enqueue_scripts` and enqueue the `wp-link` script for the required page:\n\n```\nfunction my_funky_func() {\n    wp_enqueue_script('wp-link');\n}\nadd_action('admin_enqueue_scripts', 'my_funky_func');\n```\n\nIn the JS for the edit page, `wpLink.open()` must triggered by a click event and handled:\n\n```\n    $('body').on('click', '#my-modal-trigger', function(e) {\n\n        // This can be any value. Its sole purpose is to let us know if the modal that's open\n        // is the default or a custom one.\n        window.mySpecialModalVariable = e.target.dataset.target;\n\n        // This must have a value because the link dialogue expects it to \n        // (a wp_editor instance, actually, but that part doesn't matter here...as long as it has a value).\n        wpActiveEditor = true;\n\n        // Open the link popup.\n        wpLink.open();\n\n        // So no other action is triggered.\n        return false;\n    });\n```\n\nThe submission and cancellation of the Insert/Edit Link dialogue box also needs to be handled. So off we go…\n\n```\n    function closeMyModal() {\n\n        // Again, an editor instance is expected, as upon closing .focus() is called on\n        // wpLink.textarea, so we need to provide a jQuery object to .focus() on.\n        wpLink.textarea = $('body');\n        wpLink.close();\n\n        window.mySpecialModalVariable = false;\n        e.preventDefault ? e.preventDefault() : e.returnValue = false;\n        e.stopPropagation();\n    };\n\n    // When the dialogue box's submit button is clicked...\n    $('body').on('click', '#wp-link-submit', function(e) {\n\n        var selectedItem = wpLink.getAttrs();\n\n        if (!selectedItem.href) {\n            closeMyModal();\n        }\n\n        // Do something with the selectedItem, then close the dialogue box.\n\n       closeMyModal();\n    });\n\n    // When the user clicks the cancel button, close button, or overlay...\n    $('body').on('click', '#wp-link-cancel, #wp-link-close, #wp-link-backdrop', function(e) {\n\n        // Do whatever's necessary, then...\n\n        closeMyModal();\n    });\n```\n\n### Good, but not good enough…\n\nThe above works. Great. The problem with it is that it allows you to select *any* post type. You might want this. I didn’t. So I needed to modify the AJAX call and/or the query that returns the results.\n\nIt turns out that it’s relatively simple (but not totally obvious how) to manipulate the Insert/Edit modal’s content: *intercept the AJAX request*.\n\n```\n$(document).ready(function() {\n\n    $.ajaxSetup({\n        beforeSend: function(jqXHR, data) {\n\n            // I don't want to do anything if there's no data to send.\n            if (!data.data) return true;\n\n            // I only want to modify the request if it's for my custom modal. \n            if (!window.mySpecialModalVariable) return true;\n\n            // Made it. Now, I need to know where the AJAX is going.\n            // Break down the query params into key/value pairs and find out.\n            $.each(data.data.split('&'), function(i, kv) {\n                var kv = kv.split('=');\n                if (kv[0] == 'action' && kv[1] == 'wp-link-ajax') {\n                    data.data += '&my-special-param=1';\n                }\n            });\n\n            return true;\n        }\n    });\n});\n```\n\nLooking good so far. You may have noticed the `window.mySpecialModalVariable` in the code above. This exists for the purpose of letting us know if the AJAX request is coming from a custom modal or the default one. It’s given a value when the custom modal is opened, and it’s set to false when the dialogue box is closed via a call to `closeMyModal()`.\n\nHaving this variable isn’t imperative, but if you (might ever) have a visual editor on the same page in which this code will run, you’d find that *all* AJAX requests to `wp-link-ajax` would be modified, and the selection of posts in regular Insert/Edit Link modals would be limited to the same ones in your custom modal.\n\n### And finally…\n\nAll that remains is to filter `wp_link_query_args` and check for `my-special-param`‘s presence.\n\n```\nfunction awesome_wp_link_filter($args) {\n    global $post;\n\n    if (array_key_exists('my-special-param', $_POST)) {\n        $args['post_type'] = array('my-special-post-type');\n    }\n\n    return $args;\n}\n\nadd_filter('wp_link_query_args', 'awesome_wp_link_filter', 99);\n```\n\nAnd that’s it. When the custom modal is launched, it will only display a list of `my-special-post-type`s. It might not seem like a big deal, but when you’ve got 100,000+ rows in `wp_posts`, 20+ different post types, and there are only 50 posts of the CPT you’re after, it’s nice to be able to select from a subset rather than the whole set.\n\n\n",
  "summary": "",
  "blog": "1",
  "created": "2015-11-09T15:24:39.000Z",
  "updated": "2015-11-10T10:22:54.000Z",
  "published": "2015-11-09T15:24:39.000Z",
  "contentType": "page",
  "id": "B17vaPkERl"
}