{
  "title": "Customise Insert/Edit Link Dialogue Box",
  "subtitle": "",
  "slug": "customise-insert-edit-link-dialogue-box",
  "section": "",
  "url": "/customise-insert-edit-link-dialogue-box/",
  "body": "Recently, I had to create an easy way to select a custom post type (CPT) and insert it into a different CPT’s edit page. I’ve done this this type of thing before but, the last time I did, I took the approach of creating a replicable autocomplete field (allowing the user to add as many items as they want). Autocomplete made sense in this case because, overall, I think it made the post selection process faster. Implementation, however, was relatively slow. Why? Because I had to create:\r\n\r\n- the autocomplete input field\r\n- the logic that handled replication\r\n- the logic that managed the autocomplete behaviour (yes, it was necessary)\r\n- the input sanitisation logic\r\n- the AJAX request\r\n- a *wp_ajax_* function to handle the ajax request\r\n- the code that would render the response\r\n- the code that would parse the AJAX response, as well as update some page elements\r\n\r\nNone of these steps were particularly difficult, and I could quite easily replicate them, but the approach felt like overkill this time round. Users just needed to be able to select a single instance of *one* CPT, very much like when adding a link to a post. This got me thinking and lead me to investigate using WordPress’s existing *Insert/Edit Link* modal that’s available via the visual editor.\r\n\r\n### A little less work\r\n\r\nMaking the Insert/Edit Link modal window available outside of the visual editor was simple: hook into the `admin_enqueue_scripts` and enqueue the `wp-link` script for the required page:\r\n\r\n```\r\nfunction my_funky_func() {\r\n    wp_enqueue_script('wp-link');\r\n}\r\nadd_action('admin_enqueue_scripts', 'my_funky_func');\r\n```\r\n\r\nIn the JS for the edit page, `wpLink.open()` must triggered by a click event and handled:\r\n\r\n```\r\n    $('body').on('click', '#my-modal-trigger', function(e) {\r\n\r\n        // This can be any value. Its sole purpose is to let us know if the modal that's open\r\n        // is the default or a custom one.\r\n        window.mySpecialModalVariable = e.target.dataset.target;\r\n\r\n        // This must have a value because the link dialogue expects it to \r\n        // (a wp_editor instance, actually, but that part doesn't matter here...as long as it has a value).\r\n        wpActiveEditor = true;\r\n\r\n        // Open the link popup.\r\n        wpLink.open();\r\n\r\n        // So no other action is triggered.\r\n        return false;\r\n    });\r\n```\r\n\r\nThe submission and cancellation of the Insert/Edit Link dialogue box also needs to be handled. So off we go…\r\n\r\n```\r\n    function closeMyModal() {\r\n\r\n        // Again, an editor instance is expected, as upon closing .focus() is called on\r\n        // wpLink.textarea, so we need to provide a jQuery object to .focus() on.\r\n        wpLink.textarea = $('body');\r\n        wpLink.close();\r\n\r\n        window.mySpecialModalVariable = false;\r\n        e.preventDefault ? e.preventDefault() : e.returnValue = false;\r\n        e.stopPropagation();\r\n    };\r\n\r\n    // When the dialogue box's submit button is clicked...\r\n    $('body').on('click', '#wp-link-submit', function(e) {\r\n\r\n        var selectedItem = wpLink.getAttrs();\r\n\r\n        if (!selectedItem.href) {\r\n            closeMyModal();\r\n        }\r\n\r\n        // Do something with the selectedItem, then close the dialogue box.\r\n\r\n       closeMyModal();\r\n    });\r\n\r\n    // When the user clicks the cancel button, close button, or overlay...\r\n    $('body').on('click', '#wp-link-cancel, #wp-link-close, #wp-link-backdrop', function(e) {\r\n\r\n        // Do whatever's necessary, then...\r\n\r\n        closeMyModal();\r\n    });\r\n```\r\n\r\n### Good, but not good enough…\r\n\r\nThe above works. Great. The problem with it is that it allows you to select *any* post type. You might want this. I didn’t. So I needed to modify the AJAX call and/or the query that returns the results.\r\n\r\nIt turns out that it’s relatively simple (but not totally obvious how) to manipulate the Insert/Edit modal’s content: *intercept the AJAX request*.\r\n\r\n```\r\n$(document).ready(function() {\r\n\r\n    $.ajaxSetup({\r\n        beforeSend: function(jqXHR, data) {\r\n\r\n            // I don't want to do anything if there's no data to send.\r\n            if (!data.data) return true;\r\n\r\n            // I only want to modify the request if it's for my custom modal. \r\n            if (!window.mySpecialModalVariable) return true;\r\n\r\n            // Made it. Now, I need to know where the AJAX is going.\r\n            // Break down the query params into key/value pairs and find out.\r\n            $.each(data.data.split('&'), function(i, kv) {\r\n                var kv = kv.split('=');\r\n                if (kv[0] == 'action' && kv[1] == 'wp-link-ajax') {\r\n                    data.data += '&my-special-param=1';\r\n                }\r\n            });\r\n\r\n            return true;\r\n        }\r\n    });\r\n});\r\n```\r\n\r\nLooking good so far. You may have noticed the `window.mySpecialModalVariable` in the code above. This exists for the purpose of letting us know if the AJAX request is coming from a custom modal or the default one. It’s given a value when the custom modal is opened, and it’s set to false when the dialogue box is closed via a call to `closeMyModal()`.\r\n\r\nHaving this variable isn’t imperative, but if you (might ever) have a visual editor on the same page in which this code will run, you’d find that *all* AJAX requests to `wp-link-ajax` would be modified, and the selection of posts in regular Insert/Edit Link modals would be limited to the same ones in your custom modal.\r\n\r\n### And finally…\r\n\r\nAll that remains is to filter `wp_link_query_args` and check for `my-special-param`‘s presence.\r\n\r\n```\r\nfunction awesome_wp_link_filter($args) {\r\n    global $post;\r\n\r\n    if (array_key_exists('my-special-param', $_POST)) {\r\n        $args['post_type'] = array('my-special-post-type');\r\n    }\r\n\r\n    return $args;\r\n}\r\n\r\nadd_filter('wp_link_query_args', 'awesome_wp_link_filter', 99);\r\n```\r\n\r\nAnd that’s it. When the custom modal is launched, it will only display a list of `my-special-post-type`s. It might not seem like a big deal, but when you’ve got 100,000+ rows in `wp_posts`, 20+ different post types, and there are only 50 posts of the CPT you’re after, it’s nice to be able to select from a subset rather than the whole set.\r\n\r\n\r\n",
  "featured-image": {
    "src": ""
  },
  "summary": "",
  "blog": "1",
  "created": "2015-11-09T15:24:39.000Z",
  "updated": "2017-07-25T00:42:08.701Z",
  "published": "2015-11-09T15:24:39.000Z",
  "contentType": "page",
  "id": "B17vaPkERl"
}