{
  "title": "Custom Rewrite Rules Per Post",
  "subtitle": "",
  "slug": "custom-rewrite-rules-per-post",
  "section": "",
  "url": "/custom-rewrite-rules-per-post/",
  "body": "\nI often feel like I’m coercing WordPress into doing my bidding. It makes me feel dirty. Never more has this been the case than when I was asked to find a way to allow post authors to customise the rewrite base for a custom post type (CPT). What does that mean exactly? It means that if a CPT was registered with:\n\n```\nregister_post_type('my-special-post-type', array(\n    // ...params...\n    'rewrite' => array(\n        'slug' => 'horses',\n        'with_front' => false\n     ),\n    // ...more params...\n));\n```\n\n…instead of the *my_special_post_type* post having a permalink of `http://www.mysite.com/horses/%postname%/`, the user could override the default CPT base slug of `/horses/` and force the post to use `http://www.mysite.com/unicorns/%postname%/` instead.\n\n### Hooks & Hacks\n\nIf you don’t understand [custom post types](https://codex.wordpress.org/Function_Reference/register_post_type), you have no business attempting what follows. This isn’t <del>going</del> meant to be an in-depth, step-by-step walk through. I’m mainly writing this as a means to purge the experience from my system. Honestly, it feels very hacky, which shouldn’t really be the case, considering I’m doing it all “the WordPress way”. Everything was implemented using hooks and filters. Does that mean the WordPress way is hacky? Or am I just doing it wrong? You be the judge. Right now, I don’t give a shit. It works. Flawlessly. So far…\n\n### The Process\n\nAs usual, I googled around a fair bit to see if there were any publicly demonstrated implementations I could borrow. Why reinvent the wheel, right? Unfortunately, I didn’t find any. Plan B? Work out the steps I think will be required to make it happen, then do it. The basic steps I came up with were as follows:\n\n- Add/save a field on the edit page that allows specification of the new slug.\n- Add rewrite rules based on this above custom slug.\n- With rewrite rule active, prevent access to the post via post type’s *actual* base slug.\n- Generate permalinks based on the custom slug, not the post type’s *actual* base slug.\n\nI could have started with adding the field and saving the value, but I figured that part would be easy. Instead, I started with what I thought would be the most difficult part: setting up the rewrite rules.\n\n### Dynamic Rewrite Rules\n\nSince I wouldn’t know before hand what rules would be required, I needed to work that out on the fly and add them, before WP started processing the stored rules. I hooked into `init` and created a function that retrieves posts of type `my_special_post_type` that have been assigned a custom base slug. Then I iterated through each of the found posts and added a rewrite rule for each.\n\n```\nadd_action('init', 'my_init_function');\n\nfunction my_init_function() {\n\n    add_my_special_rules();\n\n    add_filter('post_type_link', 'my_special_filter_permalink'), 10, 3);\n    add_action('template_redirect', 'my_special_override'), 1);\n}\n\nfunction add_my_special_rules() {\n    global $wpdb;\n\n    $sql = \"SELECT *\n            FROM `wp_posts`\n            JOIN `wp_postmeta` ON `post_id` = `ID`\n            WHERE `post_type` = 'my_special_post_type'\n            AND `post_status` = 'publish'\n            AND `meta_key` = 'my_special_post_options'\n            AND `meta_value` LIKE '%my_slug_override%'\";\n\n    $results = $wpdb->get_results($sql);\n\n    if ($results) {\n\n        foreach ($results as $post) {\n            $options = unserialize($post->meta_value);\n\n            if (array_key_exists('my_slug_override', $options) && empty($options['my_slug_override'])) continue;\n\n            add_rewrite_rule(\"^{$options['my_slug_override']}/({$post->post_name})/?$\", \"index.php?my_special_post_type=\\$matches[1]&post_type=my_special_post_type=\\$matches[1]\", 'top');\n        }\n    }\n}\n```\n\nThis isn’t the precise code I used, so don’t just lift it and expect it to work. My actual implementation was part of a class in a plugin, where as the above could be in the functions.php. It’s essentially the same, though. Also, it was for a hierarchical CPT, but the above is for a non-hierarchical CPT for the sake of simplicity.\n\nFor a hierarchical CPT, you might only want the override option on the top level post, and have all child pages’s slugs derived from that. You may also want to match on anything *starting with* the post name (e.g. `\"^{$options['my_slug_override']}/({$post->post_name}.*)/?$\"`, which is what’s in my original implementation) rather than what is above. It depends on the nature of the post type, I guess.\n\nAnd if you’re wondering why I added a rewrite rule for each post, rather than one for each distinct base, it’s so that posts that weren’t meant to be found via that base, aren’t. This way, a page that’s only meant to be found via `/horses/mister-ed/` won’t also be found via `/unicorns/mister-ed/`.\n\n### Override Permalinks\n\nLike a good little WP soldier, I use `get_permalink()` and `the_permalink()` (but not repeatedly within the same template!) to construct URLs whenever I can. The problem with these functions is that they determine part of the permalink structure from the `rewrite` params supplied when the post type was registered. Shit.\n\nTo get around this was fairly trivial, though. I used the `post_type_link` filter hook, added as a filter in the `init` function above. This is *not* to be confused with the `post_link` filter hook which *only* applies to posts of type `post`. It took me a few minutes of checking and double checking before I realised what was wrong.\n\n```\nfunction my_special_filter_permalink($url, $post, $leavename) {\n\n    // Only apply this filter to special features.\n    if ($post->post_type != 'my_special_post_type') return $url;\n\n    $options = get_post_meta($post->ID, 'my_special_post_options', true);\n\n    if (array_key_exists('my_slug_override', $options) && !empty($options['my_slug_override'])) {\n        $url = str_replace('/horses/', \"/{$options['my_slug_override']}/\", $url);\n    }\n\n    return $url;\n}\n```\n\n### Redirect The “Real” Permalink\n\nThe rewrite rules added dynamically via the `init` action hook make the posts with a custom base accessible (i.e. you don’t get a 404), but they’re still accessible through their “real” URL too. For example, `http://www.mysite.com/unicorns/better-than-horses/` is still accessible via `http://www.mysite.com/horses/better-than-horses/` at this point. Definitely don’t want that. For this, I hooked into the `template_redirect` action hook.\n\n```\nfunction my_special_override() {\n    global $post;\n\n    // Skip anything that's not my special post type...\n    if ($post->post_type != 'my_special_post_type') return;\n\n    // See if this thing has an override...\n    $options = get_post_meta($post->ID, 'my_special_post_options', true);\n\n    if (!array_key_exists('my_slug_override', $feature_options) || empty($feature_options['my_slug_override'])) return;\n\n    // It has an override, so should it be accessed via the current URL?\n    $current_path = $_SERVER['REQUEST_URI'];\n\n    if (strpos($current_path, \"/{$feature_options['my_slug_override']}\") !== false) return;\n\n    // It's using the wrong path, let's redirect to the right one.\n    $the_right_one = str_replace('/horses/', \"/{$feature_options['my_slug_override']}/\", $current_path);\n\n    // Fuck yea.\n    wp_redirect(home_url($the_right_one), 301);\n    exit();\n}\n```\n\nI originally tried to add a rewrite rule using the earlier method that would redirect requests for the “real” URL to the custom one. It didn’t work out. I think it was for the best.\n\n### Save The Slug\n\nI won’t bother showing the code for adding an input field or metabox to WP’s edit post page, that’s a waste of keystrokes. Nor will I bother with the whole `save_posts` action hook — it’s what I used, naturally (it’s the WordPress way, after all), but it’s not interesting.\n\nWhat’s more interesting is that `flush_rewrite_rules()`— which needs to be called once the slug override option has been saved (in my case, I saved it as post meta) — exhibited unexpected behaviour. After the post was saved, the path to the new slug didn’t work, even though the post meta was saved and `flush_rewrite_rules()` was called during the save process. However, if I then saved a new value for the slug, the URL containing the *last* slug would start working, but the latest one would not.\n\nI dug into `/wp-includes/rewrite.php` which eventually led me to this block, around line 2043:\n\n```\npublic function flush_rules($hard = true) {\n    delete_option('rewrite_rules');\n    $this->wp_rewrite_rules();\n    /**\n     * Filter whether a \"hard\" rewrite rule flush should be performed when requested.\n     *\n     * A \"hard\" flush updates .htaccess (Apache) or web.config (IIS).\n     *\n     * @since 3.7.0\n     *\n     * @param bool $hard Whether to flush rewrite rules \"hard\". Default true.\n     */\n    if ( ! $hard || ! apply_filters( 'flush_rewrite_rules_hard', true ) ) {\n        return;\n    }\n    if ( function_exists( 'save_mod_rewrite_rules' ) )\n        save_mod_rewrite_rules();\n    if ( function_exists( 'iis7_save_url_rewrite_rules' ) )\n        iis7_save_url_rewrite_rules();\n}\n```\n\nSo, I replaced `flush_rewrite_rules()` with `delete_option('rewrite_rules')` and it suddenly started working as expected. *Hallelujah*. The custom URL base was immediately functional for the post on which it had been set, and for no others (as it should be). I went even deeper and settled on the more explicit:\n\n```\n$wpdb->delete($wpdb->options, array('option_name' => 'rewrite_rules'));\n```\n\n### In closing…\n\nDespite the fact that it works, I don’t recommend implementing something like this. If a post is meant to be under a different section, then it should have the appropriate category, tag or post type. This isn’t always possible though. In my case, I had no choice, for reasons I won’t go into. Suffice it to say that simply creating special categories or tags, or a new post type, just wasn’t feasible given our setup, which is incredibly bespoke.\n\nAnd this is my typical experience of WordPress. I think it allows you to do *too much*. In trying to be everything to everyone it has become as much a whore as the language it’s written in (looking at you, *PHP*). It’s up to developers to use it sensibly. This isn’t a massive problem for small sites. But when you’ve got thousands upon thousands of posts (across many post types) and millions of visitors, those “clever” workarounds, inefficient but functional solutions, and hacky fixes end up boxing you in, inevitably forcing you to refactor, rewrite, or create even more “clever” workarounds and hacks further down the line. I suspect I’ll also end up paying for this piece of work eventually.\n\nTechnical debt is a bitch. And so is WordPress.\n\n\n",
  "summary": "",
  "blog": "1",
  "created": "2015-11-11T19:08:28.000Z",
  "updated": "2015-11-11T21:18:56.000Z",
  "published": "2015-11-11T19:08:28.000Z",
  "contentType": "page",
  "id": "BkHvaPJN0g"
}